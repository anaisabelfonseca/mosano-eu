"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTemporaryMockNodes = void 0;

var R = _interopRequireWildcard(require("ramda"));

var _graphql = require("gatsby/graphql");

var _easygraphqlMock = _interopRequireDefault(require("easygraphql-mock"));

var _gatsbySourceFilesystem = require("gatsby-source-filesystem");

var _customTypeJsonToGraphQLSchema = require("./customTypeJsonToGraphQLSchema");

var _nodeHelpers = require("./nodeHelpers");

var _normalize = require("./normalize");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

// Mock date to allow Gatsby to apply Date arguments
const MOCK_DATE = '1991-03-07'; // Mock image URL to download via createRemoteFileNode

const MOCK_IMAGE_URL = 'https://prismic.io/...2f6802b/images/favicon.png'; // Returns a copy of an object with a given prop removed at all levels.

const removePropDeep = R.curry((prop, obj) => JSON.parse(JSON.stringify(obj, (k, v) => k === prop ? undefined : v))); // Returns a mock Gatsby Node for the given type and custom type JSON schema.

const jsonSchemaToMockNode = (type, jsonSchema) => {
  // Convert the JSON schema to a collection of mock objects.
  const schema = (0, _customTypeJsonToGraphQLSchema.customTypeJsonToGraphQLSchema)(type, jsonSchema);
  const printedSchema = (0, _graphql.printSchema)(schema);
  const mockedSchema = (0, _easygraphqlMock.default)(printedSchema, {
    Date: MOCK_DATE,
    ImageURL: MOCK_IMAGE_URL
  }); // mockedSchema contains mocks for every subtype, but we only need the main
  // root mock node.

  const rootMockedNode = mockedSchema[(0, _nodeHelpers.generateTypeName)(type)];
  const MockNode = (0, _nodeHelpers.createNodeFactory)(type);
  return MockNode(rootMockedNode);
}; // Normalizes a mock image field by providing a `localFile` field using
// `gatsby-source-filesystem`. This allows for `gatsby-transformer-sharp` and
// `gatsby-image` integration. Creates one File node.


const normalizeMockImageField =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (args) {
    const {
      value,
      gatsbyContext
    } = args;
    const {
      actions: {
        createNode
      },
      createNodeId,
      store,
      cache
    } = gatsbyContext;
    const url = decodeURIComponent(value.url);
    const fileNode = yield (0, _gatsbySourceFilesystem.createRemoteFileNode)({
      url,
      store,
      cache,
      createNode,
      createNodeId
    });
    value.localFile___NODE = fileNode.id; // TODO: Resolve `children` error when fileNode is deleted with `deleteNodes`
    // later in the process.
    // return [fileNode]

    return [];
  });

  return function normalizeMockImageField(_x) {
    return _ref.apply(this, arguments);
  };
}(); // Normalizes a mock link field by providing a `document` field with a union
// type containing all custom types. The node references use the existing mock
// nodes. Creates no additional nodes.


const normalizeMockLinkField =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(function* (args) {
    const {
      value,
      rootNodes
    } = args;
    value.document___NODE = R.map(R.prop('id'), rootNodes);
    return [];
  });

  return function normalizeMockLinkField(_x2) {
    return _ref2.apply(this, arguments);
  };
}(); // Normalizes a slice zone field by recursively normalizing `item` and
// `primary` keys and returns a list of created nodes. It creates a node for
// each slice type to ensure the slice key can handle multiple (i.e. union)
// types.


const normalizeMockSliceField =
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(function* (args) {
    const {
      key,
      value,
      node,
      createNodeWithoutTypename
    } = args;
    const promises = R.map(
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(function* (sliceChoiceNode) {
        const itemNodes = yield normalizeMockGroupField(_objectSpread({}, args, {
          value: sliceChoiceNode.items
        }));
        const primaryNodes = yield normalizeMockFields(_objectSpread({}, args, {
          value: sliceChoiceNode.primary
        }));

        const typename = sliceChoiceNode.__typename.replace(/^Prismic/, '');

        const gatsbySliceChoiceNode = (0, _nodeHelpers.createNodeFactory)(typename)(sliceChoiceNode);
        createNodeWithoutTypename(gatsbySliceChoiceNode);
        return [gatsbySliceChoiceNode, ...itemNodes, ...primaryNodes];
      });

      return function (_x4) {
        return _ref4.apply(this, arguments);
      };
    }(), value);
    const createdMockNodesSegmented = yield Promise.all(promises);
    const createdMockNodes = R.flatten(createdMockNodesSegmented); // Set slice references to the created nodes. We know the first element in
    // the segmented array is the slice choice and not any of its accessory mock
    // nodes.

    node.data[`${key}___NODE`] = R.map(R.pipe(R.head, R.prop('id')), createdMockNodesSegmented);
    delete node.data[key];
    return createdMockNodes;
  });

  return function normalizeMockSliceField(_x3) {
    return _ref3.apply(this, arguments);
  };
}(); // Normalizes a mock group field by recursively normalizing each entry's field
// and returns a list of created nodes.


const normalizeMockGroupField =
/*#__PURE__*/
function () {
  var _ref5 = _asyncToGenerator(function* (args) {
    const {
      value
    } = args;
    const promises = R.pipe(R.toPairs, R.map(
    /*#__PURE__*/
    function () {
      var _ref6 = _asyncToGenerator(function* ([fieldKey, fieldValue]) {
        return yield normalizeMockFields(_objectSpread({}, args, {
          key: fieldKey,
          value: fieldValue
        }));
      });

      return function (_x6) {
        return _ref6.apply(this, arguments);
      };
    }()))(value);
    const createdMockNodesSegmented = yield Promise.all(promises);
    const createdMockNodes = R.flatten(createdMockNodesSegmented);
    return createdMockNodes;
  });

  return function normalizeMockGroupField(_x5) {
    return _ref5.apply(this, arguments);
  };
}(); // Normalizes a mock field by determining its type and returns a list of
// created nodes. If the type is not supported or needs no normalizing, an
// empty list is returned.


const normalizeMockField =
/*#__PURE__*/
function () {
  var _ref7 = _asyncToGenerator(function* (args) {
    const {
      key,
      value
    } = args;
    if ((0, _normalize.isLinkField)(value)) return yield normalizeMockLinkField(args);
    if ((0, _normalize.isImageField)(value)) return yield normalizeMockImageField(args);
    if ((0, _normalize.isSliceField)(value)) return yield normalizeMockSliceField(args);
    if ((0, _normalize.isGroupField)(value)) return yield normalizeMockGroupField(args);
    return [];
  });

  return function normalizeMockField(_x7) {
    return _ref7.apply(this, arguments);
  };
}(); // Normalizes an object of mock fields and returns a list of created nodes.


const normalizeMockFields =
/*#__PURE__*/
function () {
  var _ref8 = _asyncToGenerator(function* (args) {
    const {
      value
    } = args;
    const promises = R.pipe(R.toPairs, R.map(
    /*#__PURE__*/
    function () {
      var _ref9 = _asyncToGenerator(function* ([key, value]) {
        return yield normalizeMockField(_objectSpread({}, args, {
          key,
          value
        }));
      });

      return function (_x9) {
        return _ref9.apply(this, arguments);
      };
    }()))(value);
    const createdMockNodesSegmented = yield Promise.all(promises);
    const createdMockNodes = R.flatten(createdMockNodesSegmented);
    return createdMockNodes;
  });

  return function normalizeMockFields(_x8) {
    return _ref8.apply(this, arguments);
  };
}(); // Normalizes a mock node's data fields and returns a list of created nodes.


const normalizeMockNode =
/*#__PURE__*/
function () {
  var _ref10 = _asyncToGenerator(function* (args) {
    const {
      node
    } = args;
    return yield normalizeMockFields(_objectSpread({}, args, {
      value: node.data
    }));
  });

  return function normalizeMockNode(_x10) {
    return _ref10.apply(this, arguments);
  };
}(); // Creates and deletes temporary mock nodes from the provided custom type JSON
// schemas.
//
// This function sets up an emitter listener to automatically remove the mock
// nodes once they are unnecessary


const createTemporaryMockNodes =
/*#__PURE__*/
function () {
  var _ref11 = _asyncToGenerator(function* ({
    schemas,
    gatsbyContext
  }) {
    const {
      actions: {
        createNode,
        deleteNode
      },
      emitter
    } = gatsbyContext; // createNode function without typename injected from
    // customTypeJsonToGraphQLSchema.

    const createNodeWithoutTypename = node => createNode(removePropDeep('__typename', node)); // 1. Convert the schemas to mock nodes.


    const mockNodes = R.pipe(R.toPairs, R.map(([type, jsonSchema]) => jsonSchemaToMockNode(type, jsonSchema)))(schemas); // 2. Create the mock nodes and any necessary accessory mock nodes.
    //    Accessory mock nodes are necessary anywhere "___NODE" fields are used
    //    in the source plugin, such as Slice and Link fields.

    const promises = R.map(
    /*#__PURE__*/
    function () {
      var _ref12 = _asyncToGenerator(function* (mockNode) {
        const createdMockNodes = yield normalizeMockNode({
          node: mockNode,
          rootNodes: mockNodes,
          createNodeWithoutTypename,
          gatsbyContext
        });
        createNodeWithoutTypename(mockNode);
        return [mockNode, ...createdMockNodes];
      });

      return function (_x12) {
        return _ref12.apply(this, arguments);
      };
    }(), mockNodes); // 3. Set createdMockNodes with the list of nodes to delete later.

    const createdMockNodesSegmented = yield Promise.all(promises);
    const createdMockNodes = R.flatten(createdMockNodesSegmented); // Performed once the schema has been set so we can delete all temporary mock nodes.

    const onSchemaUpdate = () => {
      createdMockNodes.forEach(node => deleteNode({
        node
      })); // Only perform this action once

      emitter.off(`SET_SCHEMA`, onSchemaUpdate);
    }; // We will listen to when the schema is set so we can immediately remove the
    // mocked nodes. At this point, the types are already produced, rendering the
    // mock nodes unnecessary.
    //
    // THIS IS HACKY! emitter is considered more of a private API and listening
    // to internal the SET_SCHEMA message might be begging for problems.


    emitter.on(`SET_SCHEMA`, onSchemaUpdate);
  });

  return function createTemporaryMockNodes(_x11) {
    return _ref11.apply(this, arguments);
  };
}();

exports.createTemporaryMockNodes = createTemporaryMockNodes;
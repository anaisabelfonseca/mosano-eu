"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _path = _interopRequireDefault(require("path"));

var _getRootQuery = require("gatsby-source-graphql-universal/getRootQuery");

var _gatsbyNode = require("gatsby-source-graphql-universal/gatsby-node");

var _utils = require("./utils");

var _gatsbySourceFilesystem = require("gatsby-source-filesystem");

var _pathToRegexp = _interopRequireDefault(require("path-to-regexp"));

exports.onCreateWebpackConfig = _gatsbyNode.onCreateWebpackConfig;

exports.onCreatePage = function (_ref) {
  var page = _ref.page,
      actions = _ref.actions;
  var rootQuery = (0, _getRootQuery.getRootQuery)(page.componentPath);
  page.context = page.context || {};

  if (rootQuery) {
    page.context.rootQuery = rootQuery;
    actions.createPage(page);
  }
};

exports.sourceNodes = function (ref, options) {
  var opts = (0, _objectSpread2.default)({
    fieldName: _utils.fieldName,
    typeName: _utils.typeName,
    createLink: function createLink() {
      return (0, _utils.PrismicLink)({
        uri: "https://".concat(options.repositoryName, ".prismic.io/graphql"),
        credentials: 'same-origin',
        accessToken: options.accessToken,
        customRef: options.prismicRef
      });
    }
  }, options);
  return (0, _gatsbyNode.sourceNodes)(ref, opts);
};

var getPagesQuery = function getPagesQuery(_ref2) {
  var pageType = _ref2.pageType;
  return "\n  query AllPagesQuery (\n    $after: String\n  ) {\n    prismic {\n      ".concat(pageType, " (\n        first: 20\n        after: $after\n      ) {\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        edges {\n          node {\n            _meta {\n              id\n              lang\n              uid\n              alternateLanguages {\n                id\n                lang\n                type\n                uid\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n");
};

exports.createPages =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(_ref3, options) {
    var graphql, createPage, previewPath, createPageRecursively, _createPageRecursively, pages, pageCreators;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _createPageRecursively = function _ref8() {
              _createPageRecursively = (0, _asyncToGenerator2.default)(
              /*#__PURE__*/
              _regenerator.default.mark(function _callee(page) {
                var endCursor,
                    pageType,
                    query,
                    _ref5,
                    data,
                    errors,
                    toPath,
                    rootQuery,
                    hasNextPage,
                    _args = arguments;

                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        endCursor = _args.length > 1 && _args[1] !== undefined ? _args[1] : '';
                        pageType = "all".concat(page.type, "s");
                        query = getPagesQuery({
                          pageType: pageType
                        });
                        _context.next = 5;
                        return graphql(query, {
                          after: endCursor
                        });

                      case 5:
                        _ref5 = _context.sent;
                        data = _ref5.data;
                        errors = _ref5.errors;
                        toPath = _pathToRegexp.default.compile(page.match || page.path);
                        rootQuery = (0, _getRootQuery.getRootQuery)(page.component);

                        if (!(errors && errors.length)) {
                          _context.next = 12;
                          break;
                        }

                        throw errors[0];

                      case 12:
                        hasNextPage = data.prismic[pageType].pageInfo.hasNextPage;
                        endCursor = data.prismic[pageType].pageInfo.endCursor; // Cycle through each page returned from query...

                        data.prismic[pageType].edges.forEach(function (_ref6) {
                          var node = _ref6.node;
                          var params = (0, _objectSpread2.default)({}, node._meta, {
                            lang: node._meta.lang === options.defaultLang ? null : node._meta.lang
                          });
                          var path = toPath(params);

                          if (page.lang && page.lang !== node._meta.lang) {
                            return; // don't generate page in other than set language
                          } // ...and create the page


                          createPage({
                            path: path === '' ? '/' : path,
                            component: page.component,
                            context: (0, _objectSpread2.default)({
                              rootQuery: rootQuery
                            }, node._meta)
                          });
                        });

                        if (!hasNextPage) {
                          _context.next = 20;
                          break;
                        }

                        _context.next = 18;
                        return createPageRecursively(page, endCursor);

                      case 18:
                        _context.next = 21;
                        break;

                      case 20:
                        // If there are no more pages, create the preview page for this page type
                        createPage({
                          path: page.path,
                          matchPath: process.env.NODE_ENV === 'production' ? undefined : page.match,
                          component: page.component,
                          context: {
                            rootQuery: rootQuery,
                            id: '',
                            uid: '',
                            lang: options.defaultLang
                          }
                        });

                      case 21:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return _createPageRecursively.apply(this, arguments);
            };

            createPageRecursively = function _ref7(_x3) {
              return _createPageRecursively.apply(this, arguments);
            };

            graphql = _ref3.graphql, createPage = _ref3.actions.createPage;
            previewPath = options.previewPath || '/preview'; // Create top-level preview page

            createPage({
              path: previewPath.replace(/^\//, ''),
              component: _path.default.resolve(_path.default.join(__dirname, 'components', 'PreviewPage.js')),
              context: {
                prismicPreviewPage: true
              }
            }); // Helper that recursively creates 20 pages at a time for the given page type
            // (Prismic GraphQL queries only return up to 20 results per query)

            // Create all the pages!
            pages = options.pages || [];
            pageCreators = pages.map(function (page) {
              return createPageRecursively(page);
            });
            _context2.next = 9;
            return Promise.all(pageCreators);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x, _x2) {
    return _ref4.apply(this, arguments);
  };
}();

exports.createResolvers = function (_ref9, _ref10) {
  var actions = _ref9.actions,
      cache = _ref9.cache,
      createNodeId = _ref9.createNodeId,
      createResolvers = _ref9.createResolvers,
      store = _ref9.store,
      reporter = _ref9.reporter;
  var _ref10$sharpKeys = _ref10.sharpKeys,
      sharpKeys = _ref10$sharpKeys === void 0 ? [/image|photo|picture/] : _ref10$sharpKeys;
  var createNode = actions.createNode;
  var state = store.getState();

  var _state$schemaCustomiz = (0, _slicedToArray2.default)(state.schemaCustomization.thirdPartySchemas, 1),
      _state$schemaCustomiz2 = _state$schemaCustomiz[0],
      prismicSchema = _state$schemaCustomiz2 === void 0 ? {} : _state$schemaCustomiz2;

  var typeMap = prismicSchema._typeMap;
  var resolvers = {};

  for (var _typeName in typeMap) {
    var typeEntry = typeMap[_typeName];
    var typeFields = typeEntry && typeEntry.getFields && typeEntry.getFields() || {};
    var typeResolver = {};

    var _loop = function _loop(_fieldName) {
      var field = typeFields[_fieldName];

      if (field.type === typeMap.PRISMIC_Json && sharpKeys.some(function (re) {
        return re instanceof RegExp ? re.test(_fieldName) : re === _fieldName;
      })) {
        typeResolver["".concat(_fieldName, "Sharp")] = {
          type: 'File',
          args: {
            crop: {
              type: typeMap.String
            }
          },
          resolve: function resolve(source, args) {
            var obj = source && source[_fieldName] || {};
            var url = args.crop ? obj[args.crop] && obj[args.crop].url : obj.url;

            if (url) {
              return (0, _gatsbySourceFilesystem.createRemoteFileNode)({
                url: url,
                store: store,
                cache: cache,
                createNode: createNode,
                createNodeId: createNodeId,
                reporter: reporter
              });
            }

            return null;
          }
        };
      }
    };

    for (var _fieldName in typeFields) {
      _loop(_fieldName);
    }

    if (Object.keys(typeResolver).length) {
      resolvers[_typeName] = typeResolver;
    }
  }

  if (Object.keys(resolvers).length) {
    createResolvers(resolvers);
  }
};